# React의 상태관리

## React에서 상태 관리는 왜 필요한가?

### 상태(state)란 무엇일까?

상태는 컴포넌트 내부에서 관리되며 웹 어플리케이션을 렌더하는데 영향을 미칠 수 있는 자바스크립트 객체라고 정의할 수 있다. 즉 사용자와의 인터랙션을 통해 동적으로 계속해서 변화하는 데이터이며, 어플리케이션 규모가 커질수록 이런 상태들은 점점 많아지고 서로 의존성이 생기게 된다. ex) 인스타그램에서의 아이디, 팔로잉 수, 팔로워 수, 포스트, 스토리, 알림 등…

### 상태 관리가 필요한 이유

컴포넌트 내부의 상태가 변경되면 컴포넌트가 리렌더링되면서, 가상 DOM에서 변경된 부분만 실제 DOM에 반영하는 작업을 거치게 된다. 이때 이 상태를 필요로하는 다른 자식 컴포넌트에도 변경 사항을 적용해야한다. 즉, 서로 다른 컴포넌트에서 동일한 상태를 다룬다면 그 상태의 일관성과 데이터의 무결성을 반드시 지켜야한다. 따라서 React에서는 동일한 데이터는 항상 같은 출처에서 가져온다라는 Single source of Truth 방법론을 채택하고 있다.

또한 React는 기본적으로 단방향 데이터흐름 이라는 특징이 있다. 자식 컴포넌트는 기본적으로 부모로부터 전달받은 상태(데이터)를 직접 변경할 방법이 없으므로 부모로부터 상태를 변경하는 함수를 props를 통해 전달받아야 한다. 그런데, 컴포넌트의 갯수가 많아지면서 공유해야하는 상태가 무척 많아진다면 부모→자식으로 이어지는 props전달이 과도하게 많아지고, 그 깊이가 깊어질수록 이 상태가 어디서부터 내려온 것인지, 또 상태가 변경됐을 때 이것이 어디에서 어떻게 변경되는 것인지 파악하기가 매우 힘들어질 것이다. 따라서 우리는 이 상태가 예상치 못한 문제를 발생시키지 않도록 직관적으로 관리하기 위한 방법을 고민해야 한다.

## 관리해야 하는 상태에 대한 기준은 무엇인가?

앞서 언급한 상태의 정의와 같이, 사용자와의 인터랙션이나 필요로하는 로직을 구현하는데 있어서 변경될 수 있는 값을 상태로 관리해야할 것이다. 특히나 여러 컴포넌트에서 사용되는 값이라면 값이 일관되도록 관리해야만 한다. 이러한 상태를 크게 세 가지 종류로 나누어 생각해볼 수 있다.

### 상태의 세 가지 종류

- `전역 상태`(Global State) : 프로젝트 전체에 영향을 끼치는 상태로, 부모에서 자식으로 상태 값을 넘겨주는 prop drilling이 필요하다. ex) user 기능
- `컴포넌트 간 상태`(Cross Component State) : 여러가지 컴포넌트에서 관리되는 상태로, 다수의 컴포넌트 사이에서 쓰이고 서로 영향을 미친다. 따라서 이또한 prop drilling이 필요하다. ex) 여러 페이지에서 나타날 수 있는 modal
- `지역 상태`(Local State) : 특정 컴포넌트 안에서만 관리되는 상태로, 다른 컴포넌트들과 데이터를 공유하지 않는다. ex) 사용자의 입력값을 받는 input창 등

따라서 이러한 상태의 종류를 고려해서 상태를 어떻게 관리해야하는지 고민하는 것도 필요하다. 예를 들어 하나의 컴포넌트에서만 사용되는 지역 상태를 굳이 전역적으로 관리할 필요는 없을 것이다.

## 어떤 상태관리 라이브러리를 어떤 상황에서 사용해야 할까?

대부분의 상태 관리 라이브러리들은 공통적으로 `전역 상태`를 관리하는 것을 도와준다.

<img src="https://velog.velcdn.com/images/himprover/post/44969074-65c9-49fd-b8eb-5f59ed61aeb9/image.png">

Redux가 확실히 우세한 인기를 보이고 있다.

### React 전역 상태 관리의 역사

1. `props, state`
   - 단방향 데이터 흐름으로 인한 prop drilling이 문제가 되어 전역 상태 관리의 필요성이 대두되었다.
2. `Flux 아키텍처` (2014)

   <img src="https://images.velog.io/images/alskt0419/post/368e2aec-aa71-45fd-9359-8781ba90290b/%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.png">

   - 대규모 어플리케이션에서 보다 일관된 데이터를 관리하기 위해 위와 같은 아키텍처가 고안되었다.
   - 단방향으로 데이터가 흐를 수 있도록 설계되었다.

3. `Redux` (2015)
   - Flux 아키텍처를 기반으로 만들어졌다.
   - 다른 프레임워크에서도 사용 가능하다.
   - 현재까지 가장 인기 있는 라이브러리이다.
4. `MobX` (2015)
   - Redux와 마찬가지로 React에 종속적이지 않다.
   - Redux와 달리 다수의 store를 사용할 수 있다.
   - devTools, 커뮤니티가 다소 부족하다.
5. `Context API` (2018)
   - React 내장 API이므로 외부 라이브러리 없이 상태 관리를 할 수 있다.
6. `Recoil` (2020)
   - 페이스북에서 출시한 React 전용 상태 관리 라이브러리이다.

### Context API

리액트가 자체적으로 가지고 있는, 전역 상태를 공유하기 위한 방법이다. 사실 Context API는 상태를 관리한다기보다 상태에 종속성을 부여하기 위한 도구이며 실질적인 상태 관리는 useState, useReducer를 통해 이루어진다. 즉 Context API는 이미 존재하는 상태를 다른 컴포넌트들과 쉽게 공유할 수 있게 해주는 역할을 한다. useReducer와 함께 사용하면 redux와 비슷한 형태로 관리할 수도 있다.

Context API를 통해 prop drilling을 피할 수 있기 때문에 테마나 언어 등 전역적으로 쓰이는 **정적인 데이터에 자주 쓰이며, 복잡한 업데이트를 다루기보단 업데이트가 자주 발생하지 않는 상태에 사용하는 것이 적합하다. Provider로 감싸진 부분이라면, 업데이트가 일어나지 않은 상태에도 불필요한 리렌더링이 발생하기 때문이다.** → 이러한 불필요한 리렌더링을 보완하기 위해 Recoil이 나왔다.

### Redux

전역 상태를 관리하기 위한 도구로, 어플리케이션 전체에 대한 중앙 저장소 역할을 한다. 크게 Store, Reducer, Action으로 설명할 수 있다.

- `Store` : 전역 상태를 저장하는 저장소로, 자바스크립트 객체 형태로 되어있으며 오직 Reducer로만 접근할 수 있다. **여러개의 Context를 만들 수 있는 Context API와는 다르게 Redux에서 Store는 1개만 존재할 수 있다.**
- `Action` : Reducer에게 보내는 Store에 대한 행동을 정의하는 자바스크립트 객체이다. “이렇게 상태를 변경해줘” 라는 주문서의 역할이다. Action을 Reducer에게 보내려면 dispatch 메소드를 사용해야 하는데, dispatch는 Reducer에 Action 객체를 넘겨주어 상태를 업데이트한다.
- `Reducer` : 이전 상태와 Action을 받아서 다음 상태를 반환하는 함수이다. 오직 Reducer를 통해서만 전역 상태를 변경하고 업데이트할 수 있다. 이 때 이전 상태를 변경한다기보다 새로운 상태 객체를 생성해서 반환한다.

### Redux가 Context API에 비해 가지는 강점

[You Might Not Need Redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367)

1. 로컬스토리지에 상태를 영속적으로 저장하고, 시작할 때 다시 불러오는 것에 뛰어나다.
2. 상태를 Server에서 미리 채워서, HTML에 담아 Client로 보내고, 앱을 시작할 때 다시 불러오는 것에 뛰어나다.
3. 사용자의 액선을 직렬화(Serialize)해서, 상태와 함께 자동으로 버그 리포트에 첨부할 수 있고, 개발자들은 이를 통해 에러를 재현할 수 있다.
4. 액션 객체를 네트워크를 통해 보내면, 코드를 크게 바꾸지 않고도 협업 환경을 구현할 수 있다.
5. 코드를 크게 바꾸지 않고도 실행 취소 내역의 관리나 Optimistic Mutations(낙관적인 변경)을 구현할 수 있다.
6. 개발할 때, 상태 내역 사이를 오가고 액션 내역에서 현재 상태를 다시 계산하는 일을 TDD 스타일로 할 수 있다.
7. 개발자 도구가 완전한 조사, 제어를 할 수 있게 함으로써 개발자들이 자신의 앱을 위한 도구를 직접 만들 수 있게 해준다.
8. 비즈니스 로직을 대부분 재사용하면서 UI를 변경할 수 있게 한다.

### Recoil

페이스북에서 만든 라이브러리로, React에 최적화된 React 전용 라이브러리라는 것이 특징이다.

Context API는 전역 상태를 전달할 때 객체 형태의 value를 사용하므로 객체 안의 값이 하나라도 변경되면 provider로 감싼 모든 하위 컴포넌트가 리렌더링된다는 단점이 있다. 그러나 **Recoil은 각각의 전역 상태에 대한 atom이 생성되고 해당 상태를 구독하는 구성 요소만 리렌더링 되어 불필요한 리렌더링을 방지할 수 있다.**

**Redux와 비교하자면, React 전용 라이브러리가 아니고 초기 세팅(boilerplate)이 요구되며 비동기 데이터를 위해 추가적인 라이브러리 설치가 필요하다는 Redux의 단점을 보완한 라이브러리가 Recoil이다.**

### React Query

전역 상태 관리 라이브러리라기 보다는 서버와 클라이언트 간 비동기 작업을 쉽게 다룰 수 있게 도와주는 라이브러리이다. 즉, 서버 상태(백엔드에 저장된 데이터라고 생각하면 편하다)를 관리하는 라이브러리다.

보통 Redux와 같은 전역 상태 라이브러리들이 클라이언트의 상태에 대해서는 잘 동작하지만 서버 상태에 대해서는 그렇지 못하기 때문에 React Query가 비동기를 통해 서버 상태를 가져오고 관리하는 부분을 쉽게 만들어준다. API 데이터의 만료 시간, 데이터를 캐시에서 유지할 시간, 데이터 리프레시 여부, 데이터를 가져오는 것에 대한 성공, 로딩, 에러 콜백 등의 기능을 제어할 수 있다.

> 참고자료
> [https://mingule.tistory.com/74](https://mingule.tistory.com/74)
> [https://dori-coding.tistory.com/entry/React-상태관리-라이브러리-어떤걸-써야할까](https://dori-coding.tistory.com/entry/React-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%96%B4%EB%96%A4%EA%B1%B8-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C)
> [https://chanhuiseok.github.io/posts/react-15/](https://chanhuiseok.github.io/posts/react-15/)

# React의 렌더링

## React에서 렌더링을 효과적으로 관리하는 방법은 무엇이 있을까?

React에서 렌더링을 최적화하기 위한 방법으로는 다음과 같은 것들이 있다.

### State 선언 방식

- state 선언 위치 설계에 주의한다.
  React에서는 state의 변경에 따라 그 state가 선언된 컴포넌트와 그 하위 컴포넌트를 모두 리렌더링시키기 때문에 state 선언 위치를 잘 설계하는 것은 렌더링 횟수에 큰 영향을 끼친다. 일단 특정 state를 사용하는 컴포넌트들을 잘 구분해놓은 뒤 그 컴포넌트들 중 가장 최상위 컴포넌트에 선언하는 것이 기본적이다. 그보다 더 상위의 컴포넌트에 state를 선언한다면 그 state를 사용하지 않는 컴포넌트에서도 불필요한 리렌더링이 일어나게 된다.
  ```
  Index
   ㄴ Group
   ㄴ UserList
      ㄴ UserItem
  ```
  위와 같은 컴포넌트 구조를 갖는다면, UserList와 UserItem에서만 사용되는 `users` state를 어디서 선언해야 할까? 이 데이터가 사용되는 두 컴포넌트 중 가장 상위 컴포넌트인 UserList에 선언해야 한다.
- 객체 타입의 state는 최대한 분할하여 선언한다.
  객체가 크고 복잡한 구조인 경우 분할할 수 있는 만큼 최대한 분할하는 것이 좋다. 그렇지 않으면 하위 컴포넌트가 사용하지 않는 다른 값이 업데이트될 때도 리렌더링이 발생하기 때문이다.

### React.memo를 이용한 컴포넌트 메모이제이션

React.memo는 컴포넌트를 래핑하여 props를 비교함으로써 리렌더링을 막을 수 있는 메모이제이션 기법을 제공하는 함수이다. 콜백 함수를 이용해 메모이제이션을 적용할지 여부를 판단할 수도 있다.

```
Index
 ㄴ UserList
    ㄴ UserItem
```

```jsx
import React from "react";

function UserItem({ user }) {
  console.log(`UserItem (id: ${user.id}) component render`);

  return (
    <div className="user-item">
      <div>이름: {user.name}</div>
      <div>나이: {user.age}</div>
      <div>점수: {user.score}</div>
    </div>
  );
}

export default React.memo(UserItem);
```

위와 같이 React.memo를 사용하여 메모이제이션 기법을 적용하면, UserList의 길이가 변할 때 새로 변경된 UserItem만 렌더링하고 이미 렌더링된 UserItem들은 리렌더링하지 않도록 할 수 있다.

### 컴포넌트 매핑시 key값으로 index를 사용하지 않는다.

key값으로 배열의 index값을 넣게되면, 배열 중간에 어떤 요소가 삽입되었을 때 그 뒤에 위치한 요소들은 전부 인덱스가 변경된다. 이로인해 key가 변경되고 리마운트가 일어나고, 데이터와 key가 매치되지 않는 문제도 발생할 수 있다.

```jsx
return (
  <div>
    <Button
      value="배열의 맨 앞에 아이템 추가"
      disabled={users.length >= 3}
      onClick={addUser}
    />
    {users.map((user, index) => {
      return <UserItem key={index} user={user} />;
    })}
  </div>
);
```

예를들어 위와 같이 UserItem을 매핑할 때 key에 users배열의 index를 넣는다면, user 배열의 맨 앞에 새로운 아이템을 추가했을 때 기존에 key=0과 key=1에 매치되어 있던 컴포넌트들의 연결이 끊기고 각각 key=2, key=3에 새로 매치된다. key 값이 달라졌기 때문에 이 UserItem은 새로 마운트되어 메모이제이션도 적용되지 않게 된다.

따라서 key에는 고유한 id값을 넣어 배열 중간에 요소가 삽입되더라도 기존 원소들의 key가 변경되지 않도록 주의해야한다.

### useMemo

useMemo는 종속 변수들이 변하지 않으면 함수를 굳이 다시 호출하지 않고 이전에 반환한 참조값을 재사용할 수 있게 한다. 즉, 함수 호출 시간도 낭비하지 않고 같은 값을 props로 받는 하위 컴포넌트의 리렌더링을 방지할 수 있다.

```
Index
ㄴUserList
  ㄴAverage
  ㄴUserItem
```

위와 같은 구조에서 users 데이터가 변할 때마다 새로운 평균값을 계산하여 Average에 평균값을 전달하는 상황을 예로 들자. Average가 UserList의 하위에 있으므로, UserList가 리렌더링 될 때마다 평균값을 새로 계산해야할 것이다.

```jsx
const average = useMemo(() => {
  console.log("calculate average. It takes long time !!");
  return users.reduce((result, user) => {
    return result + user.score / users.length;
  }, 0);
}, [users]);
```

이런식으로 useMemo를 사용한다면 users가 변하지 않는 한 평균을 구하는 연산은 작동하지 않도록 제어할 수 있다.

### useCallback

상위 컴포넌트에서 하위 컴포넌트로 props를 넘겨줄 때 상위 컴포넌트가 리렌더링 될 때마다 상위 컴포넌트 안에 선언된 함수를 새로 생성하기 때문에 그 때마다 새 참조 함수를 하위 컴포넌트로 넘겨주게 된다. 이에 따라 하위 컴포넌트도 props가 달라졌으므로 리렌더링 하게 되는 것이다. 이 때 useCallback으로 함수를 선언하면 종속 변수들이 변하지 않는 한 굳이 함수를 재생성하지 않고 이전에 있던 참조 변수를 그대로 하위 컴포넌트에 props로 전달하여 하위 컴포넌트의 불필요한 리렌더링을 막을 수 있다.

### props로 객체를 넘겨줄 때 새 객체 생성을 주의한다.

```jsx
// 생성자 함수
<Component prop={new Obj("x")} />
// 객체 리터럴
<Component prop={{property: "x"}} />
```

props로 객체를 넘겨줄 때, 위와 같이 컴포넌트 안에서 생성자 함수나 객체 리터럴 등으로 새로 생성한 객체를 넘겨주는 것을 주의해야 한다. 이렇게 하면 이미 선언된 state를 참조하는 것이 아니라 새로 생성된 객체가 넘겨지므로 컴포넌트가 리렌더링 될 때마다 새로운 객체가 생성되어 하위 컴포넌트에 대한 메모이제이션이 작동하지 않게 된다. 따라서 생성자 함수나 객체 리터럴로 객체를 생성하여 넘겨주지 않고, state를 그대로 하위 컴포넌트로 넘겨주도록 한다.

## 이를 위해 어떤 식으로 비즈니스 설계를 진행해야 할까?

UI 측면에서는 Atomic 디자인을 적극적으로 활용하여 컴포넌트 구조를 명확하고, 직관적이고, 최소화시킬 수 있도록 해야한다. 이는 컴포넌트 리렌더링 횟수를 줄일 수 있고 구조 자체가 명확해지기 때문에 유지보수성의 향상으로 이어질 수 있다.

데이터 측면에서는 state의 적절한 설계, API 설계가 중요하다. state에서는 UI에서 사용하기 편리한 데이터 구조를 선언하는 것이 좋다. API도 화면 기획을 기반으로 의미론적으로 잘 분리된 형태로 쪼개어 만들어야 컴포넌트에서 API로 요청할 때 불필요한 데이터를 응답 데이터로 받지 않고 필요한 데이터만 적절하게 받아 리소스와 로직 낭비를 하지 않을 수 있다.

> 참고자료
> [https://cocoder16.tistory.com/36](https://cocoder16.tistory.com/36)
